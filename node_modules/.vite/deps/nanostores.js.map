{
  "version": 3,
  "sources": ["../../nanostores/task/index.js", "../../nanostores/clean-stores/index.js", "../../nanostores/atom/index.js", "../../nanostores/lifecycle/index.js", "../../nanostores/computed/index.js", "../../nanostores/deep-map/path.js", "../../nanostores/deep-map/index.js", "../../nanostores/keep-mount/index.js", "../../nanostores/listen-keys/index.js", "../../nanostores/map/index.js", "../../nanostores/map-creator/index.js"],
  "sourcesContent": ["let tasks = 0\nlet resolves = []\n\nexport function startTask() {\n  tasks += 1\n  return () => {\n    tasks -= 1\n    if (tasks === 0) {\n      let prevResolves = resolves\n      resolves = []\n      for (let i of prevResolves) i()\n    }\n  }\n}\n\nexport function task(cb) {\n  let endTask = startTask()\n  let promise = cb().finally(endTask)\n  promise.t = true\n  return promise\n}\n\nexport function allTasks() {\n  if (tasks === 0) {\n    return Promise.resolve()\n  } else {\n    return new Promise(resolve => {\n      resolves.push(resolve)\n    })\n  }\n}\n\nexport function cleanTasks() {\n  tasks = 0\n}\n", "import { cleanTasks } from '../task/index.js'\n\nexport let clean = Symbol('clean')\n\nexport let cleanStores = (...stores) => {\n  if (process.env.NODE_ENV === 'production') {\n    throw new Error(\n      'cleanStores() can be used only during development or tests'\n    )\n  }\n  cleanTasks()\n  for (let $store of stores) {\n    if ($store) {\n      if ($store.mocked) delete $store.mocked\n      if ($store[clean]) $store[clean]()\n    }\n  }\n}\n", "import { clean } from '../clean-stores/index.js'\n\nlet listenerQueue = []\nlet lqIndex = 0\nconst QUEUE_ITEMS_PER_LISTENER = 4\nexport let epoch = 0\n\nexport let atom = (initialValue) => {\n  let listeners = []\n  let $atom = {\n    get() {\n      if (!$atom.lc) {\n        $atom.listen(() => {})()\n      }\n      return $atom.value\n    },\n    lc: 0,\n    listen(listener) {\n      $atom.lc = listeners.push(listener)\n\n      return () => {\n        for (let i = lqIndex + QUEUE_ITEMS_PER_LISTENER; i < listenerQueue.length;) {\n          if (listenerQueue[i] === listener) {\n            listenerQueue.splice(i, QUEUE_ITEMS_PER_LISTENER)\n          } else {\n            i += QUEUE_ITEMS_PER_LISTENER\n          }\n        }\n\n        let index = listeners.indexOf(listener)\n        if (~index) {\n          listeners.splice(index, 1)\n          if (!--$atom.lc) $atom.off()\n        }\n      }\n    },\n    notify(oldValue, changedKey) {\n      epoch++\n      let runListenerQueue = !listenerQueue.length\n      for (let listener of listeners) {\n        listenerQueue.push(\n          listener,\n          $atom.value,\n          oldValue,\n          changedKey\n        )\n      }\n\n      if (runListenerQueue) {\n        for (lqIndex = 0; lqIndex < listenerQueue.length; lqIndex += QUEUE_ITEMS_PER_LISTENER) {\n            listenerQueue[lqIndex](\n              listenerQueue[lqIndex + 1],\n              listenerQueue[lqIndex + 2],\n              listenerQueue[lqIndex + 3]\n            )\n        }\n        listenerQueue.length = 0\n      }\n    },\n    /* It will be called on last listener unsubscribing.\n       We will redefine it in onMount and onStop. */\n    off() {},\n    set(newValue) {\n      let oldValue = $atom.value\n      if (oldValue !== newValue) {\n        $atom.value = newValue\n        $atom.notify(oldValue)\n      }\n    },\n    subscribe(listener) {\n      let unbind = $atom.listen(listener)\n      listener($atom.value)\n      return unbind\n    },\n    value: initialValue\n  }\n\n  if (process.env.NODE_ENV !== 'production') {\n    $atom[clean] = () => {\n      listeners = []\n      $atom.lc = 0\n      $atom.off()\n    }\n  }\n\n  return $atom\n}\n", "import { clean } from '../clean-stores/index.js'\n\nconst START = 0\nconst STOP = 1\nconst SET = 2\nconst NOTIFY = 3\nconst MOUNT = 5\nconst UNMOUNT = 6\nconst REVERT_MUTATION = 10\n\nexport let on = (object, listener, eventKey, mutateStore) => {\n  object.events = object.events || {}\n  if (!object.events[eventKey + REVERT_MUTATION]) {\n    object.events[eventKey + REVERT_MUTATION] = mutateStore(eventProps => {\n      // eslint-disable-next-line no-sequences\n      object.events[eventKey].reduceRight((event, l) => (l(event), event), {\n        shared: {},\n        ...eventProps\n      })\n    })\n  }\n  object.events[eventKey] = object.events[eventKey] || []\n  object.events[eventKey].push(listener)\n  return () => {\n    let currentListeners = object.events[eventKey]\n    let index = currentListeners.indexOf(listener)\n    currentListeners.splice(index, 1)\n    if (!currentListeners.length) {\n      delete object.events[eventKey]\n      object.events[eventKey + REVERT_MUTATION]()\n      delete object.events[eventKey + REVERT_MUTATION]\n    }\n  }\n}\n\nexport let onStart = ($store, listener) =>\n  on($store, listener, START, runListeners => {\n    let originListen = $store.listen\n    $store.listen = arg => {\n      if (!$store.lc && !$store.starting) {\n        $store.starting = true\n        runListeners()\n        delete $store.starting\n      }\n      return originListen(arg)\n    }\n    return () => {\n      $store.listen = originListen\n    }\n  })\n\nexport let onStop = ($store, listener) =>\n  on($store, listener, STOP, runListeners => {\n    let originOff = $store.off\n    $store.off = () => {\n      runListeners()\n      originOff()\n    }\n    return () => {\n      $store.off = originOff\n    }\n  })\n\nexport let onSet = ($store, listener) =>\n  on($store, listener, SET, runListeners => {\n    let originSet = $store.set\n    let originSetKey = $store.setKey\n    if ($store.setKey) {\n      $store.setKey = (changed, changedValue) => {\n        let isAborted\n        let abort = () => {\n          isAborted = true\n        }\n\n        runListeners({\n          abort,\n          changed,\n          newValue: { ...$store.value, [changed]: changedValue }\n        })\n        if (!isAborted) return originSetKey(changed, changedValue)\n      }\n    }\n    $store.set = newValue => {\n      let isAborted\n      let abort = () => {\n        isAborted = true\n      }\n\n      runListeners({ abort, newValue })\n      if (!isAborted) return originSet(newValue)\n    }\n    return () => {\n      $store.set = originSet\n      $store.setKey = originSetKey\n    }\n  })\n\nexport let onNotify = ($store, listener) =>\n  on($store, listener, NOTIFY, runListeners => {\n    let originNotify = $store.notify\n    $store.notify = (oldValue, changed) => {\n      let isAborted\n      let abort = () => {\n        isAborted = true\n      }\n\n      runListeners({ abort, changed, oldValue })\n      if (!isAborted) return originNotify(oldValue, changed)\n    }\n    return () => {\n      $store.notify = originNotify\n    }\n  })\n\nexport let STORE_UNMOUNT_DELAY = 1000\n\nexport let onMount = ($store, initialize) => {\n  let listener = payload => {\n    let destroy = initialize(payload)\n    if (destroy) $store.events[UNMOUNT].push(destroy)\n  }\n  return on($store, listener, MOUNT, runListeners => {\n    let originListen = $store.listen\n    $store.listen = (...args) => {\n      if (!$store.lc && !$store.active) {\n        $store.active = true\n        runListeners()\n      }\n      return originListen(...args)\n    }\n\n    let originOff = $store.off\n    $store.events[UNMOUNT] = []\n    $store.off = () => {\n      originOff()\n      setTimeout(() => {\n        if ($store.active && !$store.lc) {\n          $store.active = false\n          for (let destroy of $store.events[UNMOUNT]) destroy()\n          $store.events[UNMOUNT] = []\n        }\n      }, STORE_UNMOUNT_DELAY)\n    }\n\n    if (process.env.NODE_ENV !== 'production') {\n      let originClean = $store[clean]\n      $store[clean] = () => {\n        for (let destroy of $store.events[UNMOUNT]) destroy()\n        $store.events[UNMOUNT] = []\n        $store.active = false\n        originClean()\n      }\n    }\n\n    return () => {\n      $store.listen = originListen\n      $store.off = originOff\n    }\n  })\n}\n", "import { atom, epoch } from '../atom/index.js'\nimport { onMount } from '../lifecycle/index.js'\n\nlet computedStore = (stores, cb, batched) => {\n  if (!Array.isArray(stores)) stores = [stores]\n\n  let previousArgs\n  let currentEpoch\n  let set = () => {\n    if (currentEpoch === epoch) return\n    currentEpoch = epoch\n    let args = stores.map($store => $store.get())\n    if (!previousArgs || args.some((arg, i) => arg !== previousArgs[i])) {\n      previousArgs = args\n      let value = cb(...args)\n      if (value && value.then && value.t) {\n        value.then(asyncValue => {\n          if (previousArgs === args) {\n            // Prevent a stale set\n            $computed.set(asyncValue)\n          }\n        })\n      } else {\n        $computed.set(value)\n        currentEpoch = epoch\n      }\n    }\n  }\n  let $computed = atom(undefined)\n  let get = $computed.get\n  $computed.get = () => {\n    set()\n    return get()\n  }\n\n  let timer\n  let run = batched\n    ? () => {\n        clearTimeout(timer)\n        timer = setTimeout(set)\n      }\n    : set\n\n  onMount($computed, () => {\n    let unbinds = stores.map($store => $store.listen(run))\n    set()\n    return () => {\n      for (let unbind of unbinds) unbind()\n    }\n  })\n\n  return $computed\n}\n\nexport let computed = (stores, fn) => computedStore(stores, fn)\nexport let batched = (stores, fn) => computedStore(stores, fn, true)\n", "export function getPath(obj, path) {\n  let allKeys = getAllKeysFromPath(path)\n  let res = obj\n  for (let key of allKeys) {\n    if (res === undefined) {\n      break\n    }\n    res = res[key]\n  }\n  return res\n}\n\nexport function setPath(obj, path, value) {\n  return setByKey(obj != null ? obj : {}, getAllKeysFromPath(path), value)\n}\n\nexport function setByKey(obj, splittedKeys, value) {\n  let key = splittedKeys[0]\n  let copy = Array.isArray(obj) ? [...obj] : { ...obj }\n  if (splittedKeys.length === 1) {\n    if (value === undefined) {\n      if (Array.isArray(copy)) {\n        copy.splice(key, 1)\n      } else {\n        delete copy[key]\n      }\n    } else {\n      copy[key] = value\n    }\n    return copy\n  }\n  ensureKey(copy, key, splittedKeys[1])\n  copy[key] = setByKey(copy[key], splittedKeys.slice(1), value)\n  return copy\n}\n\nconst ARRAY_INDEX = /(.*)\\[(\\d+)\\]/\n\nfunction getAllKeysFromPath(path) {\n  return path.split('.').flatMap(key => getKeyAndIndicesFromKey(key))\n}\n\nfunction getKeyAndIndicesFromKey(key) {\n  if (ARRAY_INDEX.test(key)) {\n    let [, keyPart, index] = key.match(ARRAY_INDEX)\n    return [...getKeyAndIndicesFromKey(keyPart), index]\n  }\n  return [key]\n}\n\nconst IS_NUMBER = /^\\d+$/\nfunction ensureKey(obj, key, nextKey) {\n  if (key in obj) {\n    return\n  }\n\n  let isNum = IS_NUMBER.test(nextKey)\n\n  if (isNum) {\n    obj[key] = Array(parseInt(nextKey, 10) + 1)\n  } else {\n    obj[key] = {}\n  }\n}\n", "import { atom } from '../atom/index.js'\nimport { getPath, setPath } from './path.js'\n\nexport { getPath, setByKey, setPath } from './path.js'\n\nexport function deepMap(initial = {}) {\n  let $deepMap = atom(initial)\n  $deepMap.setKey = (key, value) => {\n    if (getPath($deepMap.value, key) !== value) {\n      let oldValue = $deepMap.value\n      $deepMap.value = setPath($deepMap.value, key, value)\n      $deepMap.notify(oldValue, key)\n    }\n  }\n  return $deepMap\n}\n", "export let keepMount = $store => {\n  $store.listen(() => {})\n}\n", "export function listenKeys($store, keys, listener) {\n  let keysSet = new Set([...keys, undefined])\n  return $store.listen((value, oldValue, changed) => {\n    if (keysSet.has(changed)) {\n      listener(value, oldValue, changed)\n    }\n  })\n}\n\nexport function subscribeKeys($store, keys, listener) {\n  let unbind = listenKeys($store, keys, listener)\n  listener($store.value)\n  return unbind\n}\n", "import { atom } from '../atom/index.js'\n\nexport let map = (initial = {}) => {\n  let $map = atom(initial)\n\n  $map.setKey = function (key, value) {\n    let oldMap = $map.value\n    if (typeof value === 'undefined' && key in $map.value) {\n      $map.value = { ...$map.value }\n      delete $map.value[key]\n      $map.notify(oldMap, key)\n    } else if ($map.value[key] !== value) {\n      $map.value = {\n        ...$map.value,\n        [key]: value\n      }\n      $map.notify(oldMap, key)\n    }\n  }\n\n  return $map\n}\n", "import { clean } from '../clean-stores/index.js'\nimport { onMount } from '../lifecycle/index.js'\nimport { map } from '../map/index.js'\n\nexport function mapCreator(init) {\n  let Creator = (id, ...args) => {\n    if (!Creator.cache[id]) {\n      Creator.cache[id] = Creator.build(id, ...args)\n    }\n    return Creator.cache[id]\n  }\n\n  Creator.build = (id, ...args) => {\n    let store = map({ id })\n    onMount(store, () => {\n      let destroy\n      if (init) destroy = init(store, id, ...args)\n      return () => {\n        delete Creator.cache[id]\n        if (destroy) destroy()\n      }\n    })\n    return store\n  }\n\n  Creator.cache = {}\n\n  if (process.env.NODE_ENV !== 'production') {\n    Creator[clean] = () => {\n      for (let id in Creator.cache) {\n        Creator.cache[id][clean]()\n      }\n      Creator.cache = {}\n    }\n  }\n\n  return Creator\n}\n"],
  "mappings": "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",
  "names": ["batched"]
}
